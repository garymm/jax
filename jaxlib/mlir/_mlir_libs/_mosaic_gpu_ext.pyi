# Copyright 2025 The JAX Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from collections.abc import Iterable, Sequence
import enum
from mlir import ir

def register_dialect(context: ir.Context, load: bool = ...) -> None: ...
def register_inliner_extensions(arg: ir.Context, /) -> None: ...

class TileTransformAttr(ir.Attribute):
  @staticmethod
  def isinstance(other_attribute: ir.Attribute) -> bool: ...
  def __repr__(self) -> str: ...
  @staticmethod
  def get(
      tiling: Sequence[int], context: ir.Context | None = None
  ) -> TileTransformAttr:
    """Creates a TileTransformAttr with the given tiling."""

  @property
  def tiling(self) -> list[int]: ...

class TransposeTransformAttr(ir.Attribute):
  @staticmethod
  def isinstance(other_attribute: ir.Attribute) -> bool: ...
  def __repr__(self) -> str: ...
  @staticmethod
  def get(
      permutation: Sequence[int], context: ir.Context | None = None
  ) -> TransposeTransformAttr:
    """Creates a TransposeTransformAttr with the given permutation."""

  @property
  def permutation(self) -> list[int]: ...

class SwizzleTransformAttr(ir.Attribute):
  @staticmethod
  def isinstance(other_attribute: ir.Attribute) -> bool: ...
  def __repr__(self) -> str: ...
  @staticmethod
  def get(
      swizzle: int, context: ir.Context | None = None
  ) -> SwizzleTransformAttr:
    """Creates a SwizzleTransformAttr with the given swizzle."""

  @property
  def swizzle(self) -> int: ...

def init_cc_mlir(arg: object, /) -> bool: ...

class Tiling:
  def __init__(self, tiles: Iterable) -> None: ...
  def tile_shape(self, shape: Sequence[int]) -> tuple: ...
  def untile_shape(self, shape: Sequence[int]) -> tuple: ...
  def tile_strides(self, strides: Sequence[int]) -> tuple: ...
  def tile_indices(self, indices: Sequence[int]) -> tuple: ...
  def untile_indices(self, indices: Sequence[int]) -> tuple: ...
  def tile_nested_shape_strides(
      self, shape: Sequence[Sequence[int]], strides: Sequence[Sequence[int]]
  ) -> tuple: ...
  def tile_dimension(self, dim: int) -> tuple: ...
  def remove_dimension(self, dim: int) -> Tiling: ...
  def canonicalize(self) -> Tiling: ...
  @property
  def tiles(self) -> tuple: ...
  def __str__(self) -> str: ...
  def __repr__(self) -> str: ...
  def __eq__(self, other: object) -> bool: ...
  def __hash__(self) -> int: ...

class Replicated:
  def __init__(self, times: int) -> None: ...
  @property
  def times(self) -> int: ...
  @times.setter
  def times(self, arg: int, /) -> None: ...
  def __repr__(self) -> str: ...
  def __hash__(self) -> int: ...
  def __eq__(self, arg: object, /) -> bool: ...

class TiledLayout:
  def __init__(
      self,
      tiling: Tiling,
      warp_dims: Iterable,
      lane_dims: Iterable,
      vector_dim: int,
      _check_canonical: bool = ...,
  ) -> None: ...
  @property
  def warp_dims(self) -> tuple: ...
  @property
  def lane_dims(self) -> tuple: ...
  @property
  def partitioned_warp_dims(self) -> tuple: ...
  @property
  def partitioned_lane_dims(self) -> tuple: ...
  @property
  def vector_length(self) -> int: ...
  @property
  def vector_dim(self) -> int: ...
  @property
  def tiling(self) -> Tiling: ...
  @property
  def tiled_tiling_shape(self) -> tuple: ...
  @property
  def tiled_tiling_rank(self) -> int: ...
  def warp_indices(self) -> tuple: ...
  def lane_indices(self) -> tuple: ...
  def canonicalize(self) -> TiledLayout: ...
  def registers_shape(self, shape: Sequence[int]) -> tuple: ...
  def registers_element_type(self, t: ir.Type) -> object: ...
  def shape_from_registers_shape(self, shape: Sequence[int]) -> tuple: ...
  @property
  def base_tile_shape(self) -> tuple: ...
  def remove_dimension(self, dim: int) -> TiledLayout: ...
  def reduce(self, axes: Iterable) -> TiledLayout: ...
  def thread_idxs(self, arg: Sequence[int], /) -> list: ...
  def __str__(self) -> str: ...
  def __repr__(self) -> str: ...
  def __hash__(self) -> int: ...
  def __eq__(self, other: object | None) -> bool: ...

class Rounding(enum.Enum):
  UP = 0

  DOWN = 1

class TileTransform:
  def __init__(
      self, tiling: Sequence[int], rounding: Rounding | None = ...
  ) -> None: ...
  def apply(self, arg: object, /) -> ir.Value: ...
  def transform_index(self, arg: Iterable, /) -> tuple: ...
  def transform_shape(self, arg: Sequence[int], /) -> tuple: ...
  def transform_strides(self, arg: Sequence[int], /) -> tuple: ...

class TrivialTransferPlan:
  def __init__(self) -> None: ...
  @property
  def tile_index_transforms(self) -> tuple: ...
  def select(self, arg: Iterable, /) -> ir.Value: ...
  def select_if_group(
      self, arg0: int, arg1: ir.Value, arg2: ir.Value, /
  ) -> ir.Value: ...

class StaggeredTransferPlan:
  def __init__(
      self, stagger: int, dim: int, size: int, group_pred: object
  ) -> None: ...
  @property
  def stagger(self) -> int: ...
  @property
  def dim(self) -> int: ...
  @property
  def size(self) -> int: ...
  @property
  def group_pred(self) -> ir.Value: ...
  @property
  def tile_index_transforms(self) -> tuple: ...
  def select(self, arg: Iterable, /) -> ir.Value: ...
  def select_if_group(
      self, arg0: int, arg1: ir.Value, arg2: ir.Value, /
  ) -> ir.Value: ...
